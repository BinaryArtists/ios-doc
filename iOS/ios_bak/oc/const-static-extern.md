# const, static, extern

## const来意

* const 推出的初始目的，正是为了取代预编译指令，消除它的缺点，同时继承它的优点。 

## const与宏 (通常比较发生在，如何定义常量字符串)

* 字符串常量：一般是抽成宏，但是苹果不推荐我们抽成宏，推荐我们使用const常量。

    - 执行时刻:宏是预编译（编译之前处理），const是编译阶段。
    - 编译检查:宏不做检查，不会报编译错误，只是替换，const会编译检查，会报编译错误。
    - 宏的好处:宏能定义一些函数，方法。 const不能。
    - 宏的坏处:使用大量宏，容易造成编译时间久，每次都需要重新替换。

* 有博客讨论使用宏与使用const的内存消耗问题，鉴于字符串的特殊性，建议对基础类型或其他，也做比较。
    - 这里说会增加内存消耗，且用双精度浮点数类型作比较：[const修饰符总结](http://blog.csdn.net/left_la/article/details/7441159)
    - 这里说不会增加内存，且使用字符串类型作比较：[const,static,extern详解（面试必备）](http://www.jianshu.com/p/bcae9719ad73)
    - 上面两篇都以偏概全，建议看客，还是自己考究一下，这类型的“知识”，要么看编译文档，要么实践出真知。

## const作用

* 【可以定义const常量，具有不可变性】const仅仅用来修饰右边的变量（基本数据变量p，指针变量*p），被const修饰的变量是只读的
* 便于进行类型检查，使编译器对处理内容有更多了解，消除了一些隐患

## const使用

* 需求1:提供一个方法，这个方法的参数是地址，里面只能通过地址读取值,不能通过地址修改值
* 需求2:提供一个方法，这个方法的参数是地址，里面不能修改参数的地址。

从需求 1，2 可以看出，这样的类型修饰符常发生在 封装的接口定义中，显式的描述约定。

## static, extern

这里不想说太多，下面说几个考察角度
* 作用域：零散代码块内？方法内？原文件内？全局？
* 存储区域：全局／静态区，编译期间分配内存地址？函数栈？
* 修饰类型：修饰变量？修饰方法？
* 生命周期：局部变量？全局变量？
* 是否有初始化值？

最后，const修饰的变量，只读数据段

## refer

1. [const,static,extern详解（面试必备）](http://www.jianshu.com/p/bcae9719ad73)
