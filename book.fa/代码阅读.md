## 代码阅读

fa：总结是按原文目录的，主要考虑，需要的地方摘录或总结，其他关键点由看者感兴趣点再另行谷歌查阅。

### 目录
*	木有新版，只有老版的电子书。
［我的观点是：技术书既要有商品属性，也要有free流通属性。作者本身，本该有开源精神。有收获的人，也应当注重分享。］

*	[0. 序言&前言](#0)
*	[1. 为啥要阅读代码？](#1)
*	[2. 基本编程元素](#2)
*	[3. 高级C数据类型](#3)
*	[4. C的数据结构](#4)
*	[5. 高级控制流程](#5)
*	[6. 应对大项目](#6)
*	[7. 编码规范和约定](#7)
*	[8. 文档](#8)
*	[9. 架构](#9)
*	[10. 代码阅读工具](#10)
*	[11. 完整的示例？](#11)
*	[12. 本书中提到的代码案例](#12)

<h3 id="0">序言&前言</h3>

*	代码阅读是消除程序中存在问题的最有效方式之一。
*	维护，是软件开发令人生厌的远亲。
*	这是一本，实用主义的书。

*	代码阅读范畴关注点：程序结构、数据类型、数据结构、控制流程、项目组织、代码规范、文档与构架。

<h3 id="1">为啥要阅读代码？</h3>
*	软件开发过程中，40%到70%的工作量是在系统首次编写完投入的，这些工作总是包括阅读、理解和修改原始代码。
*	软件复用越发被重视，高的人员流动率，开源开始、合作开发工作（包括外包、代码走查和极限编程）的重要性。
*	基于以上两点，无论代码是否易读，它们终究需要被人们阅读。

*	通过阅读本书：

		1. 能够阅读理解重要软件的代码
		2. 理解很多重要的软件开发思想
		3. 拥有阅读大多数重要的高级（或低级）编程语言的能力
		4. 理解实际软件项目的复杂性
*	以上也将成为自我评估的模糊标准！

*	工程师总是倾向于揭开盖子查看一下事物的内部结构。去粗取精、提取复用。
*	自问：“我正在阅读的代码真的是最好的吗？”
*	（可能）有趣且尚不了解的部分：语言特性、应用程序编程接口（sdk）、算法、数据结构、架构和设计模式。
*	要清楚自己在找什么：是一个系统调用、一种算法、一段代码，还是一种架构？设计一种发现目标代码的策略。定位到目标代码后，劈开不相关的部分，对它进行研究分析，必要时抽出为己用，这是一项必备技能。

*	代码演进中的阅读代码（不同的目的有不同的阅读策略）
	1. 修复缺陷
	2. 增加新功能

			首要任务是，找到实现类似特性的代码，整改以形成合适的模板。
	3. 修改现有特性

			首先找到该特性，底层实现代码。
	4. 调整代码使其适应新的环境和需求

			可能只需要关注不同的编译环境。也可能需要接口适配。
	5. 重构以加强代码的非功能性质量

<h3 id="2">基本编程元素</h3>
1. 函数和全局变量
2. while循环、条件和块
3. for 循环

		可选策略：自底向上和自顶向下的分析（调用关系、继承关系、数据流、控制流）、试探发、检查注释和外部文档。

		> 描述for语句的三个部分是表达式，而非语句
		> 在多数情形下，无限循环用来表达循环开始或结束时退出条件无法确定的呃循环

4. break和continue语句

		> 在Java程序中，break和continue可以接一个标记标志符（label identifier）

5. 字符和布尔表达式

		> 许多现代语言中，布尔表达式只对需要的部分进行求值。

6. goto语句
7. 局部重构

		> 在阅读由自己控制的代码时，要养成添加注释的习惯。

8. do循环和整数表达式
9. 再论控制结构

		> 奖惩：既要奖励顶点，也要奖励指数。文化：既要要想顶点进发，也要有高指数的激励。
		> 人们在设计傻瓜系统时常犯的错误就是低估了傻瓜的能力。

<h3 id="3">高级C数据类型</h3>
1. 指针（用法如下）

		> 创建链式数据结构
		> 引用动态分配的数据结构
		> 实现引用调用
		> 访问和遍历数据集合
		> 传递数组参数
		> 作为函数的引用
		> 作为其他值的别名（原因如下）
			>> 效率上的考虑
			>> 引用静态初始化的数据
			>> 全局环境中实现变量引用语义
		> 表示字符串
		> 直接访问系统内存

2. 结构体（用法如下）

		> 包含不同的数据并将其作为整体使用
		> 使函数可以返回多个结果
		> 创建链表类型的数据结构
		> 映射硬件设备、网络、存储媒介上的数据组织方式
		> 实现抽象数据类型
		> 以面向对象方式编写代码

3. 联合体（用法如下）

		> 有效利用内存空间
		> 实现多态
		> 使用内部表征方式访问数据

4. 动态内存分配
5. typedef声明

<h3 id="4">C的数据结构</h3>
	*	数据内部组织形式对（作用于数据上的）算法而言十分重要。

1. 向量
2. 矩阵和表
3. 栈
4. 图

<h3 id="5">高级控制流程</h3>
1. 递归
2. 异常机制
3. 并行性
4. 信号
5. 非局部跳转
6. 宏替换

<h3 id="6">应对大项目</h3>
1. 设计和实现技术
	*	可视化的软件过程和约束准则：用jira进行敏捷迭代管理、缺陷管理，用jenkins进行持续构建等
	*	重要的架构
	*	尽可能的分解（该讨论在实现层）
	*	对跨平台支持
	*	面向对象技术
	*	运算符重载
	*	库、组件和进程：在更大的粒度上，大型系统常被分解为不同的对象模块库、可重用组件等。
	*	领域专用及定制的语言和工具
	* 预处理命令的积极使用（prefix 脚本也算）

2.项目的组织（很实用哦！）
	*	源码树通常能够反映项目的架构和软件处理结构。

3. 编译过程与makefile文件
4. 配置
5. 版本控制
6. 项目专用工具
7. 测试

<h3 id="7">编码规范和约定</h3>
这个没啥好说的，每个公司都有一套或N套编码规范。

<h3 id="8">文档</h3>
这个有必要说一下，可惜我经历的每个小公司，在过程性规范上的文档，实际的执行力都是，一只大鸭蛋。

1. 文档类型
	*	系统规格说明文档（System Specification Document）
	*	软件需求规格说明（Software Requirements Specification）
	*	设计规格说明（Design Specification)
	*	系统测试规格说明（System's Test Specification)

2. 文档中存在的问题？？
3. 常见的开源文档格式？？

<h3 id="9">架构</h3>

<h3 id="10">代码阅读工具</h3>

<h3 id="12">本书中提到的代码案例</h3>
1. [GNU groff](http://www.gnu.org/software/groff/)
