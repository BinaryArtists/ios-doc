## 读 去model化和数据对象

## 尝试总结：

1. 作者出发点：
  * 去Model化
    > 去Model化，就是不使用特定对象迎合特定数据的映射的方式，来表达数据。比如我们可以使用NSDictionary，或者其他手段例如reformer、virtual record，来避免这种数据映射对象。
    > reformer 在[iOS应用架构谈 网络层设计方案](http://casatwy.com/iosying-yong-jia-gou-tan-wang-luo-ceng-she-ji-fang-an.html)讲到过。

  * 去数据对象
    > 所谓数据对象，就是把不同类型的数据映射到不同类型的对象上，这个对象仅用于表达数据，数据通过对象的property来体现。瘦Model、贫血模型就属于这一类。

  * 如何理解面向对象思想（而后，作者有提到“对象化的设计”，在我看来，这是不同的东西）
    > 面向对象思想三大特征：封装、继承、多态
    > [澄清历史](https://www.baidu.com/link?url=XE1zXj2S_EhQEvyEFqUKO-RXot1YRGDuklNgwIvcLBzD1arykNhavWmSmOgjWsiCdv0vMeuoAvFbqKsady7_Qq&wd=&eqid=db699898000fc5ab00000004574110fe)：面向对象是在结构化设计方法出现很多问题的情况下应运而生的。结构化设计方法求解问题的基本策略是从功能的角度审视问题域。转向，面向对象后，审视问题领域的视角改变了：在现实世界中存在的客体是问题域中的主角，所谓客体是指客观存在的对象实体和主观抽象的概念。通常人类观察问题的视角是这些客体，客体的属性反应客体在某一时刻的状态，客体的行为反映客体能从事的操作。
    > 结构化设计方法所采用的设计思路不是将客体作为一个整体，而是将依附于客体之上的行为抽取出来，以功能为目标来设计构造应用系统。
    > 面对问题规模的日趋扩大、环境的日趋复杂、需求变化的日趋加快，将利用计算机解决问题的基本方法统一到人类解决问题的习惯方法之上，彻底改变软件设计方法与人类解决问题的常规方式扭曲的现象迫在眉睫，这是提出面向对象的首要原因。
    > 面向对象设计的准则：模块化（对象即模块），抽象，信息隐藏，低耦合，高内聚，

  * 为什么不使用数据对象
    > 基于设计思想、领域规约，解释了为何数据对象不应该存在。

  * 去Model化都有哪些手段
    > 字典、reformer（[网络层](http://casatwy.com/iosying-yong-jia-gou-tan-wang-luo-ceng-she-ji-fang-an.html)）、Virtual Record（[持久层](http://casatwy.com/iosying-yong-jia-gou-tan-ben-di-chi-jiu-hua-fang-an-ji-dong-tai-bu-shu.html)）

2. 主要论点、论据：

  * 场景：在单个工程内部，各对象之间、各组件之间、各层之间的数据传递

  * 面向对象的思想：将一个或多个复杂功能封装成为一个聚合体，这个聚合体经过抽象后，仅暴露少部分方法，这些方法向外部获取实现功能所需要的条件后，就能完成对应功能。
    > 最后表述：一个对象事实上是对一个较小领域的一种封装。对应到本文要讨论的问题来看，如果拿一个对象去表达一套数据而非一个领域，这在一定程度上是违背面向对象的设计初衷的。

  * 导致了工程实践上代码的高耦合和组件难以复用的情况

  * 一个被封装出来的对象的活动领域，必须要小于等于当前被分割出来的子问题领域
    > 这里的活动是active的意思，也就是“有效的、激活的”的领域。

    > 假设一个工程被分割为A、B、C三个子问题领域，如果有一个对象的活动领域包括了B、C，也就是这个对象的方法集合中，既为B领域提供了方法，也为C领域提供了方法。这就是对象的活动领域大于了被分割出来的某个子问题的领域：这个对象的活动领域大于B领域，也大于C领域。

    > 这种情况是不应该出现在一个工程中的。

    > 合理的做法是B使用的对象，这个对象的方法集合里面所包含的所有方法，都只跟B领域有关，或者只是B领域下面的一部分。那么这种情况就是“一个被封装出来的对象的活动领域，必须要小于等于当前被分割出来的子问题领域”了


3. 其他：

  * （这点说的很对！！！我犯过这样的错误）可不可以单开一个工程目录结构设计的文章。比如信息流类的app、社交类app...或其他角度。
    > 没必要。

    > 工程目录设计是架构设计的副产品，先有的架构设计，后有的目录设计。只要架构设计对了，目录设计就不会错。但目录设计错了，架构设计一定错，目录设计对了，也不代表架构设计是对的。

    > 有很多人来向我提了跟你一样的要求，我知道他们想的是什么：根据目录设计来反推架构设计。

    > 这是极其愚蠢的设计方法论，我遇到的采用这种方法论的傻逼码农还挺多。

    > 对的，他们不够格当工程师，即使是“码农”，前面也必须要加“傻逼”这俩字。

4. 规约
  * 具体到编程上，不推荐过于强调“面向对象”，利用其思想解决特定问题即可！！下面来理一下概念吧：
    > 从 二进制数据 到 json/xml , 这是数据编码（encode）、解码（decode）
    > 从 http package 到 json data ，这是封包（pack）、解包（unpack）
    > 从 json data 到 oc的字典、java的map，这是实现层面的具体化，语言层面的具体表示
    > 从 oc的字典 到 数据对象（object-oriented）、数据结构（progress-oriented)，这是pack，也是更加的具像化
    > 具象化，是从抽象到具体，oc的字典就是oc语言层面的抽象物，面向对象中解耦的一个原则是，依赖于抽象（这里容器事抽象的，键值有依赖）！一旦从字典去构造数据对象，就有了硬编码的强依赖关系。这导致了层间、模块间的强依赖，是不易于执行单元测试的，也一定程度的影响了“强迫症患者”的设计一致性。而对于单元测试，其实应该更强调集成测试（这里的测试一般有：单元测试、集成测试、系统测试）
    > 结论是，数据对象不过是语言交流上的不确定性，去抽象、去接口、去协议，直接具像化，这样降低了沟通成本，导致了易用性的。。所以我不推崇，也不反对，还是一个耦合程度把控，还要看团队配置、执行流程的制定（有些小团队是没有单元测试的）。。回到现实了，真没趣。。。
    > 扩展：protocol buffer，它提供字典和数据对象的区别，等同于动态语言和静态语言，静态语言它肯定用数据对象了，而架构设计者去关心如何处理它，通常它出现在viewModel或ViewContoller中，通过解包和类型编码到数据对象，它不存在于网络层、数据层，会在胶合代码中，或直接用作present model中。
    > 所以架构设计者的个人价值观，直接影响了这里的方案制定，是用字典，还是数据对象。😄，反正我是推荐数据对象的，看着倒出字符串飘飞，就烦。。当接口到达几百个的时候，界面被产品狗图画的、复杂的向鬼一样，我就要疯掉。



### [引用原文章](http://casatwy.com/OOP_nomodel.html?utm_source=tuicool&utm_medium=referral)
